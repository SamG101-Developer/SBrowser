#pragma once
#ifndef SBROWSER_EVENT_HPP
#define SBROWSER_EVENT_HPP

#include <dom_object.hpp>
#include <ext/iterables/map.hpp>
#include <ext/macros/decorators.hpp>
#include <ext/properties/dom_property.hpp>
#include <performance/time/dom_high_res_timestamp.hpp>

#include <veque.hpp>

namespace dom
{
    namespace events {class event;}
    namespace helpers
    {
        struct event_dispatching;
        struct event_listening;
    }
    namespace internal {struct event_path_struct;}
    namespace nodes {class event_target;}
}


/*
 * https://dom.spec.whatwg.org/#interface-event
 * https://developer.mozilla.org/en-US/docs/Web/API/Event
 *
 * The Event interface represents an event which takes place in the DOM.
 *
 * An event can be triggered by the user action e.g. clicking the mouse button or tapping keyboard, or generated by APIs
 * to represent the progress of an asynchronous task. It can also be triggered programmatically, such as by calling the
 * HTMLElement.click() method of an element, or by defining the event, then sending it to a specified target using
 * EventTarget.dispatchEvent().
 *
 * There are many types of events, some of which use other interfaces based on the main Event interface. Event itself
 * contains the properties and methods which are common to all events.
 *
 * Many DOM elements can be set up to accept (or "listen" for) these events, and execute code in response to process (or
 * "handle") them. Event-handlers are usually connected (or "attached") to various HTML elements (such as <button>,
 * <div>, <span>, etc.) using EventTarget.addEventListener(), and this generally replaces using the old HTML event
 * handler attributes. Further, when properly added, such handlers can also be disconnected if needed using
 * removeEventListener().
 *
 * Note: One element can have several such handlers, even for the exact same event—particularly if separate, independent
 * code modules attach them, each for its own independent purposes. (For example, a webpage with an advertising-module
 * and statistics-module both monitoring video-watching.)
 *
 * When there are many nested elements, each with its own handler(s), event processing can become very complicated—
 * especially where a parent element receives the very same event as its child elements because "spatially" they overlap
 * so the event technically occurs in both, and the processing order of such events depends on the Event bubbling and
 * capture settings of each handler triggered.
 */
class dom::events::event : virtual public dom_object
{
public friends:
    friend class dom::nodes::event_target;
    friend struct dom::helpers::event_dispatching;
    friend struct dom::helpers::event_listening;

public constructors:
    event();
    event(const ext::string& event_type, const ext::string_any_map& event_init = {});

    ~event() override;

public static_constants:
    static constexpr unsigned char NONE = 0;
    static constexpr unsigned char CAPTURING_PHASE = 1;
    static constexpr unsigned char AT_TARGET = 2;
    static constexpr unsigned char BUBBLING_PHASE = 3;

public methods:
    auto stop_propagation() -> void;
    auto stop_immediate_propagation() -> void;
    auto prevent_default() -> void;
    auto composed_path() const -> ext::vector<nodes::event_target*>;

public properties:
    ext::dom_property<ext::string, _F> type;
    ext::dom_property<bool, _F> bubbles;
    ext::dom_property<bool, _F> cancelable;
    ext::dom_property<bool, _F> composed;

    ext::dom_property<nodes::event_target*, _F> target = nullptr;
    ext::dom_property<nodes::event_target*, _F> current_target = nullptr;
    ext::dom_property<nodes::event_target*, _F> related_target = nullptr;

    ext::dom_property<unsigned short, _F> event_phase;
    ext::dom_property<double, _F> time_stamp = performance::time::dom_high_res_timestamp();
    ext::dom_property<bool, _F> is_trusted;

    ext::dom_property<ext::vector<nodes::event_target        *>*, _F> touch_targets;
    ext::dom_property<ext::vector<internal::event_path_struct*>*, _F> path;

public internal_methods:
    auto v8(v8::Isolate *isolate) const -> ext::any override;

private internal_properties:
    bool m_stop_propagation_flag = false;
    bool m_stop_immediate_propagation_flag = false;
    bool m_canceled_flag = false;
    bool m_in_passive_listener_flag = false;
    bool m_initialized_flag = true;
    bool m_dispatch_flag = false;
};


#endif //SBROWSER_EVENT_HPP
